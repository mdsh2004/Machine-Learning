# -*- coding: utf-8 -*-
"""Expt_4_Program_3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1T86q0MUCGe9yObgL26dYEnBzzmGkmd-H
"""

# Import necessary libraries
import numpy as np
from sklearn.datasets import load_digits
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import accuracy_score, classification_report
from PIL import Image, ImageTk
import tkinter as tk
from tkinter import filedialog
import matplotlib.pyplot as plt

# Step 1: Load the digits dataset and train the logistic regression model
digits = load_digits()

# Prepare the data (flatten images into feature vectors)
X = digits.data
y = digits.target

# Split the data into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Train the logistic regression model
model = LogisticRegression(max_iter=10000)
model.fit(X_train, y_train)

# Evaluate the model
y_pred = model.predict(X_test)
print("Model Training Completed!")
print("Accuracy:", accuracy_score(y_test, y_pred))
print("Classification Report:\n", classification_report(y_test, y_pred))

# Step 2: Function to process the input image and predict the digit
def predict_digit_from_image(image_path):
    """
    This function takes the path to an image file, processes it, and returns the predicted digit.
    :param image_path: str, Path to the image file
    :return: int, Predicted digit
    """
    # Load the image and convert it to grayscale
    image = Image.open(image_path).convert('L')  # 'L' mode is for grayscale

    # Resize the image to 8x8 pixels as the model expects
    image = image.resize((8, 8))

    # Convert the image to a numpy array and scale pixel values to match the training data
    image_array = np.array(image)

    # Invert and normalize the image (similar to digits dataset where white is high intensity)
    image_array = 16 - (image_array / 16)

    # Flatten the image to a 1D array
    image_flattened = image_array.reshape(1, -1)

    # Predict the digit using the trained model
    prediction = model.predict(image_flattened)

    return prediction[0]

# Step 3: Build GUI using Tkinter
class DigitRecognitionApp:
    def __init__(self, root):
        self.root = root
        self.root.title("Handwritten Digit Recognition by Mohammed Shaikh  211P017")
        self.root.geometry("400x400")

        # Label
        self.label = tk.Label(self.root, text="Upload an image of a digit:", font=("Arial", 14))
        self.label.pack(pady=10)

        # Button to upload image
        self.upload_button = tk.Button(self.root, text="Upload Image", command=self.upload_image, font=("Arial", 12))
        self.upload_button.pack(pady=20)

        # Label to display the prediction
        self.prediction_label = tk.Label(self.root, text="", font=("Arial", 16))
        self.prediction_label.pack(pady=20)

        # Canvas to display the uploaded image
        self.canvas = tk.Canvas(self.root, width=200, height=200)
        self.canvas.pack()

    def upload_image(self):
        # Open file dialog to select image
        file_path = filedialog.askopenfilename(filetypes=[("Image files", "*.png;*.jpg;*.jpeg")])

        if file_path:
            # Load the image
            img = Image.open(file_path)
            img.thumbnail((200, 200))  # Resize image to fit on the canvas
            img_tk = ImageTk.PhotoImage(img)

            # Display image on the canvas
            self.canvas.create_image(100, 100, image=img_tk)
            self.canvas.image = img_tk

            # Predict the digit
            predicted_digit = predict_digit_from_image(file_path)

            # Display the prediction
            self.prediction_label.config(text=f"Predicted Digit: {predicted_digit}")

# Step 4: Run the application
if __name__ == "__main__":
    root = tk.Tk()
    app = DigitRecognitionApp(root)
    root.mainloop()

